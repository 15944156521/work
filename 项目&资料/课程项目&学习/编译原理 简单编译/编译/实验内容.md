 

   ① 检查变量的定义和使用是否正确：

(1) 变量是否重复定义                

注：不同语句块可以定义同名变量，但同一语句块内不能重复定义。

(2) 变量是否先定义再使用              

(3) 是否有从未使用的变量              

   ② 检查函数的定义和使用是否正确：

(1) 函数是否重复定义；               

(2) 被调用的函数是否已定义；            

(3) 调用函数时，形参和实参的参数个数是否相等。   

   

   (2) 中间代码生成：

   在实验二开发的语法分析程序中，编写相应的语义子程序，将经语法检查和语义检查的可执行语句序翻译成如下的四元式中间语言。

​            (op, arg1,arg2,result)

​    具体评分如下：

   ① ：四则运算表达式和赋值语句的四元式翻译；

② ：if语句的四元式翻译； 

③ ：循环语句的四元式翻译；

④ ：其他可执行语句的四元式翻译。

补充·：输出四元式输出时序号必须从1开始

函数调用时，如果实参数目与形参不一致，报错为函数未定义就使用 或报错为未找到符合参数数目的同名函数

函数名检查支持重载，即两个函数名相同，但参数个数不同，不算重复定义，看作是两个不同的函数

函数调用四元式格式：（call，，函数名）

参数压栈四元式：（push，，数值或变量名）

临时变量命令从t0开始连续递增，不能跳号
and优先级高于or
比较符需要生成四元式布尔表达式要按短路算法来实现。

例如if  a>b and c<d then翻译为：

 1（j>,a,b, 3)
 2（j, , , if_假语句块的第一条语句)
 3（j<, c,d 5)
 4（j, , , if_假语句块的第一条语句)
 5 .............//if_真语句块的第一条语句

 



### 项目分析：在语法分析基础上实现语义检查与中间代码生成

### 1. 整体架构概述

该项目围绕编译过程中的关键环节展开，从语法分析出发，逐步深入到语义检查和中间代码生成。这种分层设计使得编译器的各个功能模块职责清晰，易于维护和扩展。

#### 语法分析

grammaticalAnalysis.h 中的 `Parser` 类采用递归下降分析方法，根据语法规则对输入代码进行逐行解析，识别出各种语法结构。递归下降分析是一种自顶向下的分析方法，通过不断调用自身来处理嵌套的语法结构，具有直观、易于实现的优点。在解析过程中，`Parser` 类会根据不同的语法规则调用相应的方法，如 `Program` 方法处理程序的整体结构，`Stmt` 方法处理各种语句等。通过 `match` 方法对当前词法单元进行匹配，确保输入代码符合语法规则。具体来说，`match` 方法会检查当前词法单元的类型和值是否与期望的类型和值一致，如果一致则继续处理下一个词法单元，否则输出相应的错误信息并跳过错误的词法单元，避免进入无限循环。

#### 语义检查和符号表管理

SymbolTable.h 中的 `SymbolTable` 类充当语义检查的核心。它通过维护一个符号表栈，记录变量和函数的定义信息，并在代码解析过程中进行语义规则的检查，确保程序的语义正确性。符号表栈的设计使得可以方便地处理不同作用域的符号，当进入一个新的作用域时，会在栈顶添加一个新的符号表；退出作用域时，将栈顶的符号表弹出。`SymbolTable` 类提供了添加符号、查找符号、标记符号为已使用等方法，这些方法在代码解析过程中被频繁调用，用于检查变量和函数的定义和使用是否符合语义规则。

#### 中间代码生成

`QuadrupleGenerator` 类在 QuadrupleGenerator.h 中完整定义，负责将经过语法和语义检查的可执行语句转换为四元式中间语言。四元式是一种简单而有效的中间表示形式，便于后续的代码优化和目标代码生成。`QuadrupleGenerator` 类提供了生成临时变量、标签、添加四元式等功能，使得 `Parser` 类可以方便地生成中间代码。在 `Parser` 类的各个方法中，如 `CallStmt`、`AssignmentStmt`、`ConditionalStmt` 等，都会调用 `QuadrupleGenerator` 类的相应方法来生成四元式。例如，在 `CallStmt` 方法中，会先将实参压栈，然后生成函数调用的四元式；在 `AssignmentStmt` 方法中，会生成赋值操作的四元式。

##### 2. 变量是否先定义再使用

在 `SymbolTable` 类的 `markUsed` 方法中实现了变量先定义再使用的检查。具体逻辑如下：

```cpp
void markUsed(const string& name, const int row, const int col, int paramCount = -1) {
    Symbol* sym = paramCount < 0 ? lookup(name) : lookup(name, paramCount);
    if (sym) {
        sym->isUsed = true;
    } else {
        cerr << "语义错误: 使用了未声明的符号 '" << name
            << (paramCount >= 0 ? "#" + to_string(paramCount) : "")
            << "', 在 (" << row << "," << col << ")\n";
    }
}
```

该方法会调用 `lookup` 方法查找符号。如果找到符号，则将其 `isUsed` 标记为 `true`；否则，输出语义错误信息。

##### 3. 是否有从未使用的变量

在 `SymbolTable` 类的 `exitScope` 方法中实现了未使用变量的检查。具体逻辑如下：

```cpp
void exitScope() {
    if (!scopes.empty()) {
        for (const auto& pair : scopes.back()) {
            const string& name = pair.first;
            const Symbol& sym = pair.second;
            if (!sym.isUsed) {
                if (sym.isConst)
                    cerr << "语义警告: 常量 '" << name << "' 定义但未使用, 在 (" << sym.row << "," << sym.col << ")\n";
                else
                    cerr << "语义警告: 变量 '" << name << "' 定义但未使用, 在 (" << sym.row << "," << sym.col << ")\n";
            }
        }
        scopes.pop_back();
    }
}
```

该方法会遍历当前作用域中的所有符号，检查其 `isUsed` 标记。如果标记为 `false`，则输出相应的警告信息。

#### 函数检查

##### 1. 函数是否重复定义

同样在 `SymbolTable` 类的 `addSymbol` 方法中实现了函数重复定义的检查。如果当前作用域中已经存在同名的函数符号，则输出语义错误信息。

##### 2. 被调用的函数是否已定义

在 `SymbolTable` 类的 `checkFunctionCall` 方法中实现了函数是否已定义的检查。具体逻辑如下：

```cpp
bool checkFunctionCall(const string& funcName, const vector<SymbolType>& argTypes, const int row, const int col) {
    Symbol* sym = lookup(funcName, static_cast<int>(argTypes.size()));
    if (!sym) {
        cerr << "语义错误: 函数 '" << funcName << "' 未定义, 在 (" << row << "," << col << ")\n";
        return false;
    }
    if (sym->type != SYMBOL_FUNCTION) {
        cerr << "语义错误: '" << funcName << "' 不是函数, 在 (" << row << "," << col << ") ,曾作为 " << (sym->isConst ? "常量" : "变量") << " 定义, 位于 (" << sym->row << "," << sym->col << ")\n";
        return false;
    }
    return true;
}
```

该方法会调用 `lookup` 方法查找函数符号。如果未找到符号或找到的符号不是函数类型，则输出相应的错误信息，并返回 `false`；否则，返回 `true`。

##### 3. 调用函数时，形参和实参的参数个数是否相等

同样在 `SymbolTable` 类的 `checkFunctionCall` 方法中实现了形参和实参参数个数是否相等的检查。具体逻辑如下：

```cpp
if (sym->params.size() != argTypes.size()) {
    cerr << "语义错误: 函数 '" << funcName << "' 参数数量不匹配, 期望 " << sym->params.size() << " 个参数, 实际 " << argTypes.size() << " 个参数, 在 (" << row << "," << col << ")\n";
    return false;
}
```

该方法会比较函数符号的参数个数和实际传递的参数个数。如果不相等，则输出语义错误信息，并返回 `false`。

### 中间代码生成

#### 1. 四则运算表达式和赋值语句的四元式翻译

在 `Parser` 类的 `Exp`、`Term` 和 `Factor` 方法中实现了四则运算表达式的解析，在 `AssignmentStmt` 方法中实现了赋值语句的解析和四元式生成。具体逻辑如下：

##### 四则运算表达式

```cpp
TempVar Exp() {
    TempVar left = Term();
    while (currentToken.type == ARITHMETIC && (currentToken.value == "+" || currentToken.value == "-")) {
        string op = currentToken.value;
        match(ARITHMETIC);
        TempVar right = Term();
        string temp = generator.newTemp();
        generator.add(op, left.var, right.var, temp);
        left = {3, temp};
    }
    return left;
}
```

该方法会递归解析表达式，遇到加减运算符时，生成相应的四元式。

##### 赋值语句

```cpp
void AssignmentStmt() {
    match(KEYWORD,"let");
    string id = currentToken.value;
    match(IDENTIFIER);
    match(ASSIGN);
    TempVar exp = Exp();
    generator.add("=", exp.var, "", id);
    match(DELIMITER,";");
}
```

该方法会解析赋值语句，调用 `Exp` 方法解析表达式，并生成赋值的四元式。

#### 2. if 语句的四元式翻译

在 `Parser` 类的 `ConditionalStmt` 方法中实现了 `if` 语句的解析和四元式生成。具体逻辑如下：

```cpp
void ConditionalStmt() {
    match(KEYWORD, "if");
    int elseLabel = generator.newLabel();  // 条件不满足跳转
    ConditionalExp(elseLabel);
    match(KEYWORD, "then");
    Stmt();
    if (currentToken.type == KEYWORD && currentToken.value == "else") {
        match(KEYWORD);
        int endLabel = generator.newLabel();
        generator.addJump("","","",endLabel); // 跳出 if 的结束标签
        generator.addLabel(elseLabel);
        Stmt();  // else 分支语句
        generator.addLabel(endLabel);
    } else {
        generator.addLabel(elseLabel);
    }
    match(KEYWORD, "fi");
}
```

该方法会解析 `if` 语句，生成条件判断和跳转的四元式。

#### 3. 循环语句的四元式翻译

在 `Parser` 类的 `LoopStmt` 方法中实现了循环语句的解析和四元式生成。具体逻辑如下：

```cpp
void LoopStmt() {
    match(KEYWORD,"while");
    int startLabel = generator.newLabel(); // 循环跳回
    int endLabel = generator.newLabel(); // 结束

    generator.addLabel(startLabel);

    ConditionalExp(endLabel);

    match(KEYWORD,"do");
    Stmt();

    generator.addJump("","","",startLabel);

    generator.addLabel(endLabel);
    match(KEYWORD,"endwh");
}
```

该方法会解析循环语句，生成循环条件判断和跳转的四元式。

#### 4. 其他可执行语句的四元式翻译

在 `Parser` 类的 `CallStmt` 和 `ReturnStmt` 等方法中实现了其他可执行语句的解析和四元式生成。例如，`CallStmt` 方法会生成函数调用的四元式：

```cpp
void CallStmt() {
    int row = currentToken.row, col = currentToken.col;
    match(KEYWORD,"call");
    string funcName = currentToken.value;
    match(IDENTIFIER);
    match(DELIMITER,"(");
    vector<pair<string,SymbolType>> args = ActParamList();
    for (int i = static_cast<int>(args.size())-1; i >= 0; --i) {
        generator.add("push", "", "", args[i].first);
    }
    symbolTable.checkFunctionCall(funcName,
        [&] {
            vector<SymbolType> t;
            for(auto &p:args)
                t.push_back(p.second);
            return t;
    }(), row,col);
    generator.add("call", "", "", funcName); // 生成函数调用的四元式
    match(DELIMITER,")");
    match(DELIMITER,";");
}
```

通过以上的语义检查和中间代码生成机制，程序实现了对变量和函数的定义与使用的检查，并将可执行语句翻译成了四元式中间语言。

两个程序（`grammaticalAnalysis.h` 和 `QuadrupleGenerator.h`）协作实现四元式生成功能的方式如下：

------

### 1. `grammaticalAnalysis.h` —— 语法分析与语义动作

- 负责递归下降语法分析，识别各种语句（如赋值、四则运算、if、while、函数调用等）。
- 在分析每种语句时，**调用 `QuadrupleGenerator` 的接口**，生成对应的四元式。
- 例如：
  - 赋值语句时：`generator.add("=", exp.var, "", id);`
  - 四则运算时：`generator.add(op, left.var, right.var, temp);`
  - if/while 跳转时：`generator.addJump(...)`、`generator.addLabel(...)`
  - 函数调用时：`generator.add("call", "", "", funcName);`
- 语法分析结束后，返回所有生成的四元式。

------

### 2. `QuadrupleGenerator.h` —— 四元式生成与管理

- 提供四元式的数据结构和生成接口。
- 负责管理四元式的存储、临时变量编号、标签编号。
- 提供 `add`、`addJump`、`addLabel` 等方法，供语法分析器调用。
- 提供 `printQuadruples` 方法输出所有四元式。
- 提供 `resolveLabels` 方法，将标签转换为实际行号，便于后续处理。

------

### 协作流程简述

1. **语法分析器（Parser）**在分析每个语句时，根据语法结构调用 `QuadrupleGenerator` 的方法生成四元式。
2. **四元式生成器（QuadrupleGenerator）**负责记录、编号、输出所有四元式。
3. 最终在主程序中，调用 `Quadruple::printQuadruples` 输出所有四元式。

------

**总结：**

- `grammaticalAnalysis.h` 负责“何时、为何生成四元式”。
- `QuadrupleGenerator.h` 负责“如何生成、存储和输出四元式”。
- 两者通过接口函数（如 `add`、`addJump`、`addLabel`）协作，实现完整的四元式中间代码生成。

**补充**  

`Parser` 类定义在文件 grammaticalAnalysis.h 中。这个类用于实现语法分析，采用递归下降分析方法，同时承担了语义检查和中间代码生成的部分功能。



### 总结

该项目通过 `SymbolTable` 类、`Parser` 类和 `QuadrupleGenerator` 类的协同工作，实现了从源程序到中间代码的转换过程。`SymbolTable` 类确保了代码的语义正确性，避免了变量和函数的使用错误；`Parser` 类负责语法分析和中间代码生成的调度；`QuadrupleGenerator` 类将可执行语句翻译成四元式中间语言，为后续的代码优化和目标代码生成奠定了基础。这种分层设计和模块化实现的方式，使得编译器具有良好的可维护性和扩展性。
