<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>配音工具 - 文本转语音</title>
    <!-- Tailwind CSS v3 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome -->
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- 统一的 Tailwind 配置 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#6B7280',
                        accent: '#F59E0B',
                        dark: '#1E293B',
                        light: '#F8FAFC'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    },
                    animation: {
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .text-shadow {
                text-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .glass {
                background: rgba(255, 255, 255, 0.25);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.18);
            }
            .transition-all-300 {
                transition: all 300ms ease-in-out;
            }
            .emotion-btn.active {
                background-color: theme('colors.primary');
                color: white;
            }
        }
    </style>
    <style>
        /* 自定义滑块样式 */
        input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            background: #e2e8f0;
            border-radius: 5px;
            background-image: linear-gradient(#3B82F6, #3B82F6);
            background-repeat: no-repeat;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #3B82F6;
            cursor: pointer;
            box-shadow: 0 0 2px 0 #555;
            transition: background .3s ease-in-out;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #2563EB;
        }

        input[type="range"]::-webkit-slider-runnable-track {
            -webkit-appearance: none;
            box-shadow: none;
            border: none;
            background: transparent;
        }

        /* 波形动画 */
        @keyframes wave {
            0% { transform: scaleY(0.5); }
            50% { transform: scaleY(1.0); }
            100% { transform: scaleY(0.5); }
        }

        .wave-bar {
            animation: wave 1.2s ease-in-out infinite;
            animation-delay: calc(var(--delay) * 0.1s);
        }

        /* 滚动条样式 */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-7xl">
        <!-- 头部 -->
        <header class="mb-8 text-center">
            <h1 class="text-4xl font-bold text-dark text-shadow mb-2">配音工具</h1>
            <p class="text-secondary text-lg">将文本转换为高质量语音，支持多种音色和参数调节</p>
        </header>

        <!-- 主要内容区 -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- 左侧：文本编辑区 -->
            <div class="lg:col-span-2 bg-white rounded-xl shadow-lg p-6 overflow-hidden">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-semibold text-dark flex items-center">
                        <i class="fa fa-file-text-o mr-2 text-primary"></i>文本编辑
                    </h2>
                    <div class="flex space-x-2">
                        <button id="clearText" class="px-3 py-1 text-sm bg-gray-100 hover:bg-gray-200 rounded-lg text-secondary transition-all-300">
                            <i class="fa fa-trash-o mr-1"></i>清空
                        </button>
                        <button id="sampleText" class="px-3 py-1 text-sm bg-gray-100 hover:bg-gray-200 rounded-lg text-secondary transition-all-300">
                            <i class="fa fa-file-text mr-1"></i>示例
                        </button>
                    </div>
                </div>
                
                <div class="relative">
                    <textarea id="textInput" rows="12" class="w-full p-4 border border-gray-200 rounded-lg focus:ring-2 focus:ring-primary focus:border-primary outline-none transition-all-300 resize-none" placeholder="请输入或粘贴需要转换为语音的文本..."></textarea>
                    <div id="textCount" class="absolute bottom-3 right-3 text-xs text-secondary">0 字符</div>
                </div>
                
                <div class="mt-4 flex flex-wrap gap-2">
                    <button id="formatBold" class="px-3 py-1 text-sm bg-gray-100 hover:bg-gray-200 rounded-lg text-secondary transition-all-300">
                        <i class="fa fa-bold"></i>
                    </button>
                    <button id="formatItalic" class="px-3 py-1 text-sm bg-gray-100 hover:bg-gray-200 rounded-lg text-secondary transition-all-300">
                        <i class="fa fa-italic"></i>
                    </button>
                    <button id="formatUnderline" class="px-3 py-1 text-sm bg-gray-100 hover:bg-gray-200 rounded-lg text-secondary transition-all-300">
                        <i class="fa fa-underline"></i>
                    </button>
                    <div class="h-6 border-r border-gray-300 mx-1"></div>
                    <button id="insertPause" class="px-3 py-1 text-sm bg-gray-100 hover:bg-gray-200 rounded-lg text-secondary transition-all-300">
                        <i class="fa fa-pause mr-1"></i>插入停顿
                    </button>
                </div>
            </div>

            <!-- 右侧：语音参数控制面板 -->
            <div class="bg-white rounded-xl shadow-lg p-6">
                <h2 class="text-xl font-semibold text-dark flex items-center mb-4">
                    <i class="fa fa-sliders mr-2 text-primary"></i>语音设置
                </h2>
                
                <!-- 语音选择 -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-secondary mb-2">选择语音</label>
                    <div class="relative">
                        <select id="voiceSelect" class="w-full p-3 border border-gray-200 rounded-lg appearance-none focus:ring-2 focus:ring-primary focus:border-primary outline-none transition-all-300">
                            <option value="">加载中...</option>
                        </select>
                        <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-3 text-secondary">
                            <i class="fa fa-chevron-down"></i>
                        </div>
                    </div>
                </div>
                
                <!-- 语速调节 -->
                <div class="mb-6">
                    <div class="flex justify-between items-center mb-2">
                        <label class="block text-sm font-medium text-secondary">语速</label>
                        <span id="rateValue" class="text-sm text-primary font-medium">1.0x</span>
                    </div>
                    <input type="range" id="rateSlider" min="0.5" max="2" step="0.1" value="1" class="w-full">
                </div>
                
                <!-- 音调调节 -->
                <div class="mb-6">
                    <div class="flex justify-between items-center mb-2">
                        <label class="block text-sm font-medium text-secondary">音调</label>
                        <span id="pitchValue" class="text-sm text-primary font-medium">1.0x</span>
                    </div>
                    <input type="range" id="pitchSlider" min="0.5" max="2" step="0.1" value="1" class="w-full">
                </div>
                
                <!-- 音量调节 -->
                <div class="mb-6">
                    <div class="flex justify-between items-center mb-2">
                        <label class="block text-sm font-medium text-secondary">音量</label>
                        <span id="volumeValue" class="text-sm text-primary font-medium">100%</span>
                    </div>
                    <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1" class="w-full">
                </div>
                
                <!-- 情感风格 -->
                <div class="mb-6">
                    <label class="block text-sm font-medium text-secondary mb-2">情感风格</label>
                    <div class="grid grid-cols-2 gap-2">
                        <button class="emotion-btn px-3 py-2 text-sm bg-gray-100 hover:bg-primary hover:text-white rounded-lg transition-all-300" data-rate="1" data-pitch="1">
                            <i class="fa fa-smile-o mr-1"></i>默认
                        </button>
                        <button class="emotion-btn px-3 py-2 text-sm bg-gray-100 hover:bg-primary hover:text-white rounded-lg transition-all-300" data-rate="1.2" data-pitch="1.2">
                            <i class="fa fa-grin-o mr-1"></i>高兴
                        </button>
                        <button class="emotion-btn px-3 py-2 text-sm bg-gray-100 hover:bg-primary hover:text-white rounded-lg transition-all-300" data-rate="0.8" data-pitch="0.8">
                            <i class="fa fa-frown-o mr-1"></i>悲伤
                        </button>
                        <button class="emotion-btn px-3 py-2 text-sm bg-gray-100 hover:bg-primary hover:text-white rounded-lg transition-all-300" data-rate="0.9" data-pitch="1.1">
                            <i class="fa fa-meh-o mr-1"></i>严肃
                        </button>
                    </div>
                </div>
                
                <!-- AI智能断句 -->
                <div class="mb-6">
                    <label class="flex items-center justify-between cursor-pointer">
                        <span class="text-sm font-medium text-secondary">AI智能断句</span>
                        <div class="relative">
                            <input type="checkbox" id="smartPunctuation" class="sr-only">
                            <div class="block bg-gray-200 w-14 h-8 rounded-full"></div>
                            <div class="dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition-all-300"></div>
                        </div>
                    </label>
                    <p class="text-xs text-secondary mt-1">根据文本内容自动调整语音语调</p>
                </div>
                
                <!-- 操作按钮 -->
                <div class="flex space-x-3">
                    <button id="generateAudio" class="flex-1 px-4 py-3 bg-primary hover:bg-blue-600 text-white rounded-lg transition-all-300 flex items-center justify-center">
                        <i class="fa fa-play-circle mr-2"></i>生成语音
                    </button>
                    <button id="downloadAudio" class="px-4 py-3 bg-gray-100 hover:bg-gray-200 text-secondary rounded-lg transition-all-300 flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        <i class="fa fa-download"></i>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- 底部：播放控制和音频可视化区域 -->
        <div class="mt-6 bg-white rounded-xl shadow-lg p-6">
            <div class="flex flex-col md:flex-row md:items-center justify-between mb-4">
                <h2 class="text-xl font-semibold text-dark flex items-center mb-3 md:mb-0">
                    <i class="fa fa-volume-up mr-2 text-primary"></i>音频预览
                </h2>
                
                <!-- 播放控制 -->
                <div class="flex items-center space-x-4">
                    <button id="playPauseBtn" class="px-4 py-2 bg-primary hover:bg-blue-600 text-white rounded-lg transition-all-300 flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        <i class="fa fa-play mr-2"></i><span>播放</span>
                    </button>
                    <button id="stopBtn" class="px-4 py-2 bg-gray-100 hover:bg-gray-200 text-secondary rounded-lg transition-all-300 flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        <i class="fa fa-stop mr-2"></i><span>停止</span>
                    </button>
                    <div id="statusIndicator" class="hidden items-center">
                        <span class="inline-block w-3 h-3 bg-green-500 rounded-full animate-pulse mr-2"></span>
                        <span class="text-sm text-secondary">正在播放</span>
                    </div>
                </div>
            </div>
            
            <!-- 音频可视化 -->
            <div class="relative h-32 bg-gray-50 rounded-lg overflow-hidden">
                <!-- 波形可视化区域 -->
                <canvas id="waveformCanvas" class="w-full h-full"></canvas>
                
                <!-- 初始状态提示 -->
                <div id="initialState" class="absolute inset-0 flex flex-col items-center justify-center">
                    <div class="flex space-x-1 mb-3">
                        <div class="wave-bar w-1 h-6 bg-primary rounded-full" style="--delay: 0"></div>
                        <div class="wave-bar w-1 h-8 bg-primary rounded-full" style="--delay: 1"></div>
                        <div class="wave-bar w-1 h-10 bg-primary rounded-full" style="--delay: 2"></div>
                        <div class="wave-bar w-1 h-12 bg-primary rounded-full" style="--delay: 3"></div>
                        <div class="wave-bar w-1 h-10 bg-primary rounded-full" style="--delay: 4"></div>
                        <div class="wave-bar w-1 h-8 bg-primary rounded-full" style="--delay: 5"></div>
                        <div class="wave-bar w-1 h-6 bg-primary rounded-full" style="--delay: 6"></div>
                    </div>
                    <p class="text-sm text-secondary">点击"生成语音"按钮开始</p>
                </div>
                
                <!-- 加载状态 -->
                <div id="loadingState" class="absolute inset-0 flex flex-col items-center justify-center hidden">
                    <div class="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-primary mb-3"></div>
                    <p class="text-sm text-secondary">正在生成语音...</p>
                </div>
            </div>
            
            <!-- 音频进度条 -->
            <div class="mt-4">
                <div class="flex justify-between items-center mb-1">
                    <span id="currentTime" class="text-xs text-secondary">00:00</span>
                    <span id="duration" class="text-xs text-secondary">00:00</span>
                </div>
                <div class="relative">
                    <div id="progressBackground" class="w-full h-2 bg-gray-200 rounded-full overflow-hidden">
                        <div id="progressBar" class="h-full bg-primary rounded-full" style="width: 0%"></div>
                    </div>
                    <div id="progressHandle" class="absolute w-4 h-4 bg-white border-2 border-primary rounded-full -mt-1 cursor-pointer" style="left: 0%; transform: translateX(-50%); display: none;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 全局变量
        let synth = window.speechSynthesis;
        let voices = [];
        let currentUtterance = null;
        let audioBlob = null;
        let audioUrl = null;
        let audioElement = null;
        let audioContext = null;
        let analyser = null;
        let animationId = null;
        let isPlaying = false;
        let isPaused = false;
        let startTime = 0;
        let pausedTime = 0;
        let isRecording = false;
        let mediaRecorder = null;
        let audioChunks = [];
        
        // DOM 元素
        const textInput = document.getElementById('textInput');
        const textCount = document.getElementById('textCount');
        const voiceSelect = document.getElementById('voiceSelect');
        const rateSlider = document.getElementById('rateSlider');
        const rateValue = document.getElementById('rateValue');
        const pitchSlider = document.getElementById('pitchSlider');
        const pitchValue = document.getElementById('pitchValue');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeValue = document.getElementById('volumeValue');
        const smartPunctuation = document.getElementById('smartPunctuation');
        const generateAudioBtn = document.getElementById('generateAudio');
        const downloadAudioBtn = document.getElementById('downloadAudio');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusIndicator = document.getElementById('statusIndicator');
        const waveformCanvas = document.getElementById('waveformCanvas');
        const ctx = waveformCanvas.getContext('2d');
        const initialState = document.getElementById('initialState');
        const loadingState = document.getElementById('loadingState');
        const progressBar = document.getElementById('progressBar');
        const progressHandle = document.getElementById('progressHandle');
        const progressBackground = document.getElementById('progressBackground');
        const currentTimeDisplay = document.getElementById('currentTime');
        const durationDisplay = document.getElementById('duration');
        const clearTextBtn = document.getElementById('clearText');
        const sampleTextBtn = document.getElementById('sampleText');
        const formatBoldBtn = document.getElementById('formatBold');
        const formatItalicBtn = document.getElementById('formatItalic');
        const formatUnderlineBtn = document.getElementById('formatUnderline');
        const insertPauseBtn = document.getElementById('insertPause');
        const emotionBtns = document.querySelectorAll('.emotion-btn');
        
        // 初始化
        document.addEventListener('DOMContentLoaded', () => {
            // 设置Canvas尺寸
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // 检查浏览器支持
            if (!synth) {
                console.error('您的浏览器不支持语音合成功能，请使用Chrome、Edge或Safari浏览器。');
                generateAudioBtn.disabled = true;
                return;
            }
            
            // 添加语音测试工具的链接
            const helpContainer = document.createElement('div');
            helpContainer.className = 'fixed bottom-4 right-4';
            helpContainer.innerHTML = `
                <a href="test-voices.html" target="_blank" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-blue-600 transition-all-300 flex items-center text-sm">
                    <i class="fa fa-question-circle mr-2"></i>语音测试
                </a>
            `;
            document.body.appendChild(helpContainer);
            
            console.log('初始化配音工具...');
            
            // 显示加载中状态
            voiceSelect.innerHTML = '<option value="">正在加载可用语音...</option>';
            
            // 添加按钮点击事件来手动刷新语音列表
            const refreshVoicesBtn = document.createElement('button');
            refreshVoicesBtn.id = 'refreshVoices';
            refreshVoicesBtn.className = 'px-3 py-1 text-sm bg-gray-100 hover:bg-gray-200 rounded-lg text-secondary transition-all-300 ml-2';
            refreshVoicesBtn.innerHTML = '<i class="fa fa-refresh mr-1"></i>刷新';
            refreshVoicesBtn.onclick = () => {
                console.log('手动刷新语音列表...');
                voiceSelect.innerHTML = '<option value="">正在刷新语音列表...</option>';
                // 强制刷新语音列表
                synth.cancel(); // 先取消任何正在进行的语音合成
                
                // 多次尝试加载语音
                let attempts = 0;
                const maxAttempts = 5;
                
                const tryLoadVoices = () => {
                    attempts++;
                    console.log(`尝试加载语音 (${attempts}/${maxAttempts})...`);
                    loadVoices();
                    
                    // 如果没有加载到语音且尝试次数未用完，继续尝试
                    if (voices.length === 0 && attempts < maxAttempts) {
                        setTimeout(tryLoadVoices, 500);
                    } else if (voices.length === 0) {
                        console.log('多次尝试后仍未加载到语音');
                        console.log('无法加载语音，请检查浏览器权限设置或稍后再试');
                    }
                };
                
                tryLoadVoices();
            };
            
            // 将刷新按钮添加到文本编辑区的按钮组中
            const buttonGroup = document.querySelector('.flex.space-x-2');
            buttonGroup.appendChild(refreshVoicesBtn);
            
            // 监听语音变化事件
            if (synth.onvoiceschanged !== undefined) {
                console.log('设置语音变化事件监听器');
                synth.onvoiceschanged = () => {
                    console.log('检测到语音变化事件');
                    loadVoices();
                };
            }
            
            // 立即尝试加载一次
            console.log('首次尝试加载语音...');
            loadVoices();
            
            // 设置定时器，确保即使没有触发onvoiceschanged事件也能加载语音
            setTimeout(() => {
                if (voices.length === 0) {
                    console.log('定时器触发，再次尝试加载语音');
                    loadVoices();
                    
                    // 如果仍然没有语音，显示提示
                    if (voices.length === 0) {
                        console.log('语音加载可能需要一些时间，请点击"刷新"按钮重试');
                    }
                }
            }, 2000);
            
            // 事件监听
            setupEventListeners();
        });
        
        // 调整Canvas尺寸
        function resizeCanvas() {
            const container = waveformCanvas.parentElement;
            waveformCanvas.width = container.clientWidth;
            waveformCanvas.height = container.clientHeight;
        }
        
        // 加载可用语音
        function loadVoices(event = null) {
            console.log('开始加载语音...');
            
            // 获取语音列表
            const availableVoices = synth.getVoices();
            console.log('从synth.getVoices()获取到的语音数量:', availableVoices.length);
            
            // 更新全局变量
            voices = availableVoices;
            
            // 清空选择框
            voiceSelect.innerHTML = '';
            
            // 如果没有语音，显示提示
            if (voices.length === 0) {
                console.log('未检测到可用语音');
                const option = document.createElement('option');
                option.value = '';
                option.textContent = '未检测到可用语音';
                voiceSelect.appendChild(option);
                
                // 不显示重复的通知，只在手动刷新时显示
                if (event && event.type === 'click') {
                    console.log('未检测到可用语音，请检查浏览器设置或更新浏览器。');
                }
                return;
            }
            
            console.log('检测到的语音详情:', voices.map(v => ({ name: v.name, lang: v.lang, localService: v.localService })));
            
            // 按语言分组
            const voicesByLang = {};
            voices.forEach(voice => {
                if (!voicesByLang[voice.lang]) {
                    voicesByLang[voice.lang] = [];
                }
                voicesByLang[voice.lang].push(voice);
            });
            
            console.log('按语言分组:', Object.keys(voicesByLang));
            
            // 优先显示中文语音
            if (voicesByLang['zh-CN'] || voicesByLang['zh-TW'] || voicesByLang['zh']) {
                console.log('找到中文语音');
                addVoicesToSelect(voicesByLang, ['zh-CN', 'zh-TW', 'zh'], '中文');
            }
            
            // 添加其他语言
            Object.keys(voicesByLang).forEach(lang => {
                if (!lang.startsWith('zh')) {
                    const langName = getLanguageName(lang);
                    addVoicesToSelect(voicesByLang, [lang], langName);
                }
            });
            
            // 如果没有语音选项被添加（这种情况理论上不会发生）
            if (voiceSelect.children.length === 0) {
                console.log('没有语音选项被添加，使用通用组');
                // 添加所有语音到一个通用组
                const optgroup = document.createElement('optgroup');
                optgroup.label = '所有可用语音';
                
                voices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.name;
                    option.textContent = `${voice.name} (${voice.lang}) - ${getVoiceGender(voice)}`;
                    optgroup.appendChild(option);
                });
                
                voiceSelect.appendChild(optgroup);
            }
            
            // 默认选择第一个语音
            if (voiceSelect.options.length > 0) {
                voiceSelect.options[0].selected = true;
                console.log('默认选择语音:', voiceSelect.options[0].text);
            }
            
            // 启用生成按钮
            generateAudioBtn.disabled = false;
            console.log('语音加载完成，生成按钮已启用');
        }
        
        // 将语音添加到选择框
        function addVoicesToSelect(voicesByLang, langs, label) {
            console.log(`添加${label}语音组`);
            
            const optgroup = document.createElement('optgroup');
            optgroup.label = label;
            
            langs.forEach(lang => {
                if (voicesByLang[lang]) {
                    console.log(`添加${lang}语言的${voicesByLang[lang].length}个语音`);
                    
                    voicesByLang[lang].forEach(voice => {
                        const option = document.createElement('option');
                        option.value = voice.name;
                        
                        // 添加更详细的语音信息
                        const gender = getVoiceGender(voice);
                        const isLocal = voice.localService ? '本地' : '在线';
                        
                        option.textContent = `${voice.name} (${gender}, ${isLocal})`;
                        
                        // 添加语音的语言信息作为title属性，便于用户了解
                        option.title = `${voice.lang} - ${isLocal}语音`;
                        
                        optgroup.appendChild(option);
                    });
                }
            });
            
            if (optgroup.children.length > 0) {
                voiceSelect.appendChild(optgroup);
                console.log(`成功添加${optgroup.children.length}个${label}语音选项`);
            }
        }
        
        // 获取语言名称
        function getLanguageName(code) {
            const languages = {
                'en-US': '英语(美国)',
                'en-GB': '英语(英国)',
                'ja-JP': '日语',
                'ko-KR': '韩语',
                'fr-FR': '法语',
                'de-DE': '德语',
                'es-ES': '西班牙语',
                'ru-RU': '俄语',
                'ar-SA': '阿拉伯语',
                'hi-IN': '印地语'
            };
            return languages[code] || code;
        }
        
        // 获取语音性别
        function getVoiceGender(voice) {
            // 首先检查voice对象是否有gender属性
            if (voice.gender) {
                switch (voice.gender) {
                    case 'female':
                        return '女声';
                    case 'male':
                        return '男声';
                    default:
                        return '中性';
                }
            }
            
            // 如果没有gender属性，通过名称推断
            const name = voice.name.toLowerCase();
            
            // 中文女声关键词
            const femaleKeywords = ['female', 'woman', 'girl', 'tingting', 'yaoyao', 'lily', 'lucy', 'mary', 'sarah', 'jane'];
            // 中文男声关键词
            const maleKeywords = ['male', 'man', 'boy', 'zhiwei', 'daming', 'tom', 'john', 'mike', 'david', 'jack'];
            
            if (femaleKeywords.some(keyword => name.includes(keyword))) {
                return '女声';
            } else if (maleKeywords.some(keyword => name.includes(keyword))) {
                return '男声';
            }
            
            // 如果无法推断，返回"未知"而不是"中性"，更准确
            return '未知';
        }
        
        // 设置事件监听
        function setupEventListeners() {
            // 文本输入
            textInput.addEventListener('input', updateTextCount);
            
            // 滑块事件
            rateSlider.addEventListener('input', () => {
                rateValue.textContent = `${rateSlider.value}x`;
                updateSliderBackground(rateSlider);
            });
            
            pitchSlider.addEventListener('input', () => {
                pitchValue.textContent = `${pitchSlider.value}x`;
                updateSliderBackground(pitchSlider);
            });
            
            volumeSlider.addEventListener('input', () => {
                volumeValue.textContent = `${Math.round(volumeSlider.value * 100)}%`;
                updateSliderBackground(volumeSlider);
            });
            
            // 开关切换
            smartPunctuation.addEventListener('change', () => {
                const dot = document.querySelector('.dot');
                if (smartPunctuation.checked) {
                    dot.classList.add('translate-x-6', 'bg-primary');
                } else {
                    dot.classList.remove('translate-x-6', 'bg-primary');
                }
            });
            
            // 按钮事件
            generateAudioBtn.addEventListener('click', generateAudio);
            downloadAudioBtn.addEventListener('click', downloadAudio);
            playPauseBtn.addEventListener('click', togglePlayPause);
            stopBtn.addEventListener('click', stopAudio);
            
            // 进度条拖动
            progressBackground.addEventListener('click', seek);
            progressHandle.addEventListener('mousedown', startDrag);
            
            // 通知相关功能已移除，使用控制台输出
            
            // 文本操作
            clearTextBtn.addEventListener('click', clearText);
            sampleTextBtn.addEventListener('click', insertSampleText);
            formatBoldBtn.addEventListener('click', () => formatText('bold'));
            formatItalicBtn.addEventListener('click', () => formatText('italic'));
            formatUnderlineBtn.addEventListener('click', () => formatText('underline'));
            insertPauseBtn.addEventListener('click', insertPause);
            
            // 情感风格按钮
            emotionBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const rate = parseFloat(btn.dataset.rate);
                    const pitch = parseFloat(btn.dataset.pitch);
                    
                    rateSlider.value = rate;
                    pitchSlider.value = pitch;
                    rateValue.textContent = `${rate}x`;
                    pitchValue.textContent = `${pitch}x`;
                    
                    updateSliderBackground(rateSlider);
                    updateSliderBackground(pitchSlider);
                    
                    // 高亮选中的按钮
                    emotionBtns.forEach(b => b.classList.remove('bg-primary', 'text-white'));
                    btn.classList.add('bg-primary', 'text-white');
                });
            });
            
            // 页面可见性变化时停止播放
            document.addEventListener('visibilitychange', () => {
                if (document.hidden && isPlaying) {
                    stopAudio();
                }
            });
        }
        
        // 更新滑块背景
        function updateSliderBackground(slider) {
            const min = slider.min || 0;
            const max = slider.max || 100;
            const value = slider.value || 0;
            const percentage = ((value - min) / (max - min)) * 100;
            slider.style.backgroundSize = `${percentage}% 100%`;
        }
        
        // 更新文本计数
        function updateTextCount() {
            const count = textInput.value.length;
            textCount.textContent = `${count} 字符`;
        }
        
        // 生成音频
        function generateAudio() {
            console.log('开始生成音频...');
            
            const text = textInput.value.trim();
            if (!text) {
                console.log('请输入要转换的文本');
                return;
            }
            
            const selectedVoice = voiceSelect.value;
            if (!selectedVoice) {
                console.log('请选择一个语音或点击"刷新"按钮重新加载语音列表');
                return;
            }
            
            // 检查是否存在该语音
            const voice = voices.find(v => v.name === selectedVoice);
            if (!voice) {
                console.error('未找到选中的语音，请尝试刷新语音列表');
                console.error('未找到语音:', selectedVoice, '可用语音:', voices.map(v => v.name));
                return;
            }
            
            console.log('选中的语音:', voice);
            
            // 显示加载状态
            initialState.classList.add('hidden');
            loadingState.classList.remove('hidden');
            generateAudioBtn.disabled = true;
            
            // 停止当前播放
            stopAudio();
            
            // 创建语音合成实例
            currentUtterance = new SpeechSynthesisUtterance();
            
            // 处理文本（包括停顿标记）
            let processedText = text;
            
            // 处理插入的停顿标记
            processedText = processedText.replace(/<break time="(\d+)ms"\/>/g, (match, time) => {
                // 在Web Speech API中，我们可以用特殊字符或空格来模拟停顿
                // 这里我们使用多个空格来模拟停顿
                const pauseLength = parseInt(time) / 100; // 转换为大约的空格数
                return ' '.repeat(Math.max(5, pauseLength));
            });
            
            currentUtterance.text = processedText;
            currentUtterance.voice = voice;
            currentUtterance.rate = parseFloat(rateSlider.value);
            currentUtterance.pitch = parseFloat(pitchSlider.value);
            currentUtterance.volume = parseFloat(volumeSlider.value);
            
            console.log('语音合成参数:', {
                text: processedText.substring(0, 50) + '...',
                rate: currentUtterance.rate,
                pitch: currentUtterance.pitch,
                volume: currentUtterance.volume
            });
            
            // 智能断句处理
            if (smartPunctuation.checked) {
                console.log('应用智能断句');
                applySmartPunctuation(currentUtterance);
            }
            
            // 事件处理
            currentUtterance.onend = () => {
                isPlaying = false;
                resetPlayButton();
                hideStatusIndicator();
                resetProgress();
                
                // 如果有音频URL，创建音频元素用于可视化
                if (audioUrl) {
                    createAudioElement();
                }
            };
            
            currentUtterance.onerror = (event) => {
                console.error('语音合成错误:', event);
                console.error('语音合成失败: ' + event.error);
                isPlaying = false;
                resetPlayButton();
                hideStatusIndicator();
                resetProgress();
                resetUI();
            };
            
            // 简化版本：直接使用Web Speech API播放，不尝试捕获音频
            // 这是更可靠的方式，避免AudioContext的复杂性
            
            console.log('开始语音合成...');
            
            // 显示状态
            showStatusIndicator();
            isPlaying = true;
            updatePlayButton();
            
            // 估算完成时间并重置UI
            const estimatedDuration = estimateDuration(processedText) * 1000;
            console.log('预计播放时间:', estimatedDuration, 'ms');
            
            // 尝试使用AudioContext捕获音频
            if (window.AudioContext || window.webkitAudioContext) {
                console.log('使用AudioContext捕获音频');
                try {
                    // 初始化AudioContext
                    if (audioContext) {
                        audioContext.close();
                    }
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // 创建媒体流目标
                    const destination = audioContext.createMediaStreamDestination();
                    
                    // 清空之前的音频数据
                    audioChunks = [];
                    
                    // 创建MediaRecorder
                    mediaRecorder = new MediaRecorder(destination.stream);
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                            console.log('收到音频数据:', event.data.size);
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        console.log('录音停止，总共收到:', audioChunks.length, '个数据块');
                        if (audioChunks.length > 0) {
                            audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                            audioUrl = URL.createObjectURL(audioBlob);
                            console.log('创建了音频URL:', audioUrl);
                            
                            // 启用下载按钮
                            downloadAudioBtn.disabled = false;
                            
                            // 创建音频元素用于可视化
                            createAudioElement();
                            
                            console.log('语音生成完成，可下载或重新播放');
                        } else {
                            console.warn('没有捕获到音频数据');
                            console.log('语音播放完成，但无法捕获音频数据');
                        }
                        
                        // 重置UI
                        resetUI();
                    };
                    
                    mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder错误:', event);
                        console.error('音频捕获失败: ' + event.error);
                        resetUI();
                    };
                    
                    // 开始录音
                    mediaRecorder.start();
                    isRecording = true;
                    console.log('MediaRecorder开始');
                    
                    // 开始语音合成
                    synth.speak(currentUtterance);
                    
                    // 设置定时器在预计完成时间后停止录音
                    setTimeout(() => {
                        if (isRecording && mediaRecorder && mediaRecorder.state !== 'inactive') {
                            try {
                                mediaRecorder.stop();
                                isRecording = false;
                                console.log('MediaRecorder停止');
                            } catch (error) {
                                console.error('停止MediaRecorder失败:', error);
                            }
                        }
                    }, estimatedDuration + 1000); // 增加1秒缓冲
                    
                } catch (error) {
                    console.error('AudioContext错误:', error);
                    // 回退到简单播放
                    synth.speak(currentUtterance);
                    
                    // 设置定时器在预计完成时间后重置UI
                    setTimeout(() => {
                        if (isPlaying) {
                            // 如果仍然在播放，可能是估算不准确，延长时间
                            setTimeout(() => {
                                resetUI();
                            }, 2000);
                        } else {
                            resetUI();
                        }
                    }, estimatedDuration + 1000);
                }
            } else {
                // 不支持AudioContext，直接播放
                console.log('不支持AudioContext，直接播放');
                synth.speak(currentUtterance);
                
                // 设置定时器在预计完成时间后重置UI
                setTimeout(() => {
                    console.log('语音生成完成');
                    resetUI();
                }, estimatedDuration + 1000);
            }
        }
        
        // 应用智能断句
        function applySmartPunctuation(utterance) {
            console.log('应用智能断句前:', utterance.text.substring(0, 50) + '...');
            
            // 这里只是一个简单的实现，实际应用中可能需要更复杂的NLP处理
            let text = utterance.text;
            
            // 在句号、问号、感叹号后添加停顿（多个空格）
            text = text.replace(/([。！？.!?])([^\s])/g, '$1   $2');
            
            // 在逗号后添加较短停顿
            text = text.replace(/([，,](?![^<>]*>))([^\s])/g, '$1  $2');
            
            // 在分号和冒号后添加中等停顿
            text = text.replace(/([；；:;])([^\s])/g, '$1  $2');
            
            utterance.text = text;
            
            // 调整语速和音调
            const originalRate = utterance.rate;
            const originalPitch = utterance.pitch;
            
            // 分析文本内容
            const hasQuestion = text.includes('?') || text.includes('？');
            const hasExclamation = text.includes('!') || text.includes('！');
            const hasLongSentences = text.split(/[。！？.!?]/).some(s => s.length > 50);
            
            if (hasQuestion) {
                utterance.pitch = originalPitch * 1.1; // 疑问句提高音调
                console.log('检测到疑问句，调整音调:', utterance.pitch);
            }
            
            if (hasExclamation) {
                utterance.rate = originalRate * 1.05; // 感叹句略微加快语速
                console.log('检测到感叹句，调整语速:', utterance.rate);
            }
            
            if (hasLongSentences) {
                utterance.rate = originalRate * 0.95; // 长句子略微放慢语速
                console.log('检测到长句子，调整语速:', utterance.rate);
            }
            
            console.log('应用智能断句后:', utterance.text.substring(0, 50) + '...');
            console.log('断句后参数:', { rate: utterance.rate, pitch: utterance.pitch });
        }
        
        // 估计语音持续时间
        function estimateDuration(text) {
            // 简单估算：平均每个字符0.1秒
            const baseDuration = text.length * 0.1;
            const rate = parseFloat(rateSlider.value);
            return baseDuration / rate;
        }
        
        // 创建音频元素用于可视化
        function createAudioElement() {
            if (!audioUrl) return;
            
            // 停止当前音频
            if (audioElement) {
                audioElement.pause();
                audioElement.remove();
            }
            
            // 创建新的音频元素
            audioElement = new Audio(audioUrl);
            
            // 设置事件监听
            audioElement.addEventListener('loadedmetadata', () => {
                // 更新持续时间显示
                durationDisplay.textContent = formatTime(audioElement.duration);
                
                // 启用播放按钮
                playPauseBtn.disabled = false;
                stopBtn.disabled = false;
                
                // 准备可视化
                setupVisualization();
            });
            
            audioElement.addEventListener('timeupdate', updateProgress);
            audioElement.addEventListener('ended', () => {
                isPlaying = false;
                resetPlayButton();
                hideStatusIndicator();
                resetProgress();
            });
            
            audioElement.addEventListener('error', (event) => {
                console.error('音频加载错误:', event);
                console.error('音频加载失败');
            });
        }
        
        // 设置音频可视化
        function setupVisualization() {
            if (!audioContext || !audioElement) return;
            
            try {
                // 创建分析器
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                
                // 创建音频源
                const source = audioContext.createMediaElementSource(audioElement);
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                
                // 清除初始状态
                initialState.classList.add('hidden');
                loadingState.classList.add('hidden');
                
                // 开始绘制波形
                drawWaveform();
            } catch (error) {
                console.error('设置可视化失败:', error);
                // 可视化失败不影响音频播放
            }
        }
        
        // 绘制波形
        function drawWaveform() {
            if (!analyser) return;
            
            // 请求下一帧
            animationId = requestAnimationFrame(drawWaveform);
            
            // 获取时域数据
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);
            
            // 清除画布
            ctx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
            
            // 设置线条样式
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#3B82F6';
            ctx.beginPath();
            
            // 计算每个数据点的宽度
            const sliceWidth = waveformCanvas.width / bufferLength;
            let x = 0;
            
            // 绘制波形
            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * waveformCanvas.height / 2;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                
                x += sliceWidth;
            }
            
            // 完成路径
            ctx.lineTo(waveformCanvas.width, waveformCanvas.height / 2);
            ctx.stroke();
        }
        
        // 播放/暂停切换
        function togglePlayPause() {
            if (!audioElement && !currentUtterance) {
                console.log('请先生成语音');
                return;
            }
            
            if (audioElement) {
                // 使用音频元素播放
                if (isPlaying && !isPaused) {
                    // 暂停
                    audioElement.pause();
                    isPaused = true;
                    pauseVisualization();
                    updatePlayButton();
                } else {
                    // 播放或恢复
                    if (isPaused) {
                        audioElement.play();
                        isPaused = false;
                        resumeVisualization();
                    } else {
                        // 从头开始播放
                        audioElement.currentTime = 0;
                        audioElement.play();
                    }
                    isPlaying = true;
                    showStatusIndicator();
                    updatePlayButton();
                }
            } else if (currentUtterance) {
                // 直接使用语音合成播放
                if (isPlaying) {
                    synth.pause();
                    isPaused = true;
                    updatePlayButton();
                } else {
                    if (isPaused) {
                        synth.resume();
                        isPaused = false;
                    } else {
                        synth.speak(currentUtterance);
                    }
                    isPlaying = true;
                    showStatusIndicator();
                    updatePlayButton();
                }
            }
        }
        
        // 停止音频
        function stopAudio() {
            // 停止语音合成
            synth.cancel();
            
            // 停止录音
            if (isRecording && mediaRecorder && mediaRecorder.state !== 'inactive') {
                try {
                    mediaRecorder.stop();
                    isRecording = false;
                    console.log('停止录音');
                } catch (error) {
                    console.error('停止录音失败:', error);
                }
            }
            
            // 停止音频元素
            if (audioElement) {
                audioElement.pause();
                audioElement.currentTime = 0;
            }
            
            // 停止可视化
            stopVisualization();
            
            // 重置状态
            isPlaying = false;
            isPaused = false;
            resetPlayButton();
            hideStatusIndicator();
            resetProgress();
        }
        
        // 暂停可视化
        function pauseVisualization() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }
        
        // 恢复可视化
        function resumeVisualization() {
            if (!animationId && analyser) {
                drawWaveform();
            }
        }
        
        // 停止可视化
        function stopVisualization() {
            pauseVisualization();
            
            // 清除画布
            if (ctx) {
                ctx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
            }
        }
        
        // 更新播放按钮
        function updatePlayButton() {
            const icon = playPauseBtn.querySelector('i');
            const text = playPauseBtn.querySelector('span');
            
            if (isPlaying) {
                if (isPaused) {
                    icon.className = 'fa fa-play mr-2';
                    text.textContent = '继续';
                } else {
                    icon.className = 'fa fa-pause mr-2';
                    text.textContent = '暂停';
                }
            } else {
                icon.className = 'fa fa-play mr-2';
                text.textContent = '播放';
            }
        }
        
        // 重置播放按钮
        function resetPlayButton() {
            const icon = playPauseBtn.querySelector('i');
            const text = playPauseBtn.querySelector('span');
            icon.className = 'fa fa-play mr-2';
            text.textContent = '播放';
        }
        
        // 显示状态指示器
        function showStatusIndicator() {
            statusIndicator.classList.remove('hidden');
            statusIndicator.classList.add('flex');
        }
        
        // 隐藏状态指示器
        function hideStatusIndicator() {
            statusIndicator.classList.add('hidden');
            statusIndicator.classList.remove('flex');
        }
        
        // 更新进度
        function updateProgress() {
            if (!audioElement) return;
            
            const currentTime = audioElement.currentTime;
            const duration = audioElement.duration;
            
            if (isNaN(duration)) return;
            
            // 更新进度条
            const progress = (currentTime / duration) * 100;
            progressBar.style.width = `${progress}%`;
            progressHandle.style.left = `${progress}%`;
            
            // 更新时间显示
            currentTimeDisplay.textContent = formatTime(currentTime);
            durationDisplay.textContent = formatTime(duration);
            
            // 显示进度手柄
            if (progress > 0) {
                progressHandle.style.display = 'block';
            }
        }
        
        // 重置进度
        function resetProgress() {
            progressBar.style.width = '0%';
            progressHandle.style.left = '0%';
            progressHandle.style.display = 'none';
            currentTimeDisplay.textContent = '00:00';
            durationDisplay.textContent = '00:00';
        }
        
        // 跳转播放位置
        function seek(event) {
            if (!audioElement) return;
            
            const rect = progressBackground.getBoundingClientRect();
            const pos = (event.clientX - rect.left) / rect.width;
            const seekTime = pos * audioElement.duration;
            
            audioElement.currentTime = seekTime;
            updateProgress();
        }
        
        // 开始拖动进度条
        function startDrag(event) {
            event.preventDefault();
            
            const onMouseMove = (e) => {
                const rect = progressBackground.getBoundingClientRect();
                let pos = (e.clientX - rect.left) / rect.width;
                pos = Math.max(0, Math.min(1, pos));
                
                const seekTime = pos * audioElement.duration;
                progressBar.style.width = `${pos * 100}%`;
                progressHandle.style.left = `${pos * 100}%`;
                currentTimeDisplay.textContent = formatTime(seekTime);
            };
            
            const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                
                // 设置音频位置
                if (audioElement) {
                    const pos = parseFloat(progressHandle.style.left) / 100;
                    audioElement.currentTime = pos * audioElement.duration;
                }
            };
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }
        
        // 格式化时间
        function formatTime(seconds) {
            if (isNaN(seconds)) return '00:00';
            
            const minutes = Math.floor(seconds / 60);
            seconds = Math.floor(seconds % 60);
            
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // 下载音频
        function downloadAudio() {
            if (!audioBlob) {
                console.log('请先生成语音');
                return;
            }
            
            const url = URL.createObjectURL(audioBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = '配音输出.wav';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('音频文件已下载');
        }
        
        // 重置UI
        function resetUI() {
            generateAudioBtn.disabled = false;
            loadingState.classList.add('hidden');
            
            // 如果没有音频元素，显示初始状态
            if (!audioElement) {
                initialState.classList.remove('hidden');
            }
        }
        
        // 清空文本
        function clearText() {
            textInput.value = '';
            updateTextCount();
        }
        
        // 插入示例文本
        function insertSampleText() {
            const sampleText = "欢迎使用配音工具！这是一个示例文本，您可以在此基础上修改，或者输入您自己的内容。\n\n这个工具支持多种语音选择，您可以调整语速、音调和音量，还可以选择不同的情感风格。\n\n希望这个工具能帮助您创建出满意的配音作品！";
            textInput.value = sampleText;
            updateTextCount();
        }
        
        // 格式化文本
        function formatText(type) {
            const start = textInput.selectionStart;
            const end = textInput.selectionEnd;
            const selectedText = textInput.value.substring(start, end);
            
            if (!selectedText) {
                console.log('请先选择要格式化的文本');
                return;
            }
            
            let formattedText = '';
            
            switch (type) {
                case 'bold':
                    formattedText = `<b>${selectedText}</b>`;
                    break;
                case 'italic':
                    formattedText = `<i>${selectedText}</i>`;
                    break;
                case 'underline':
                    formattedText = `<u>${selectedText}</u>`;
                    break;
            }
            
            // 替换选中文本
            const newText = textInput.value.substring(0, start) + formattedText + textInput.value.substring(end);
            textInput.value = newText;
            
            // 重新设置选区
            const newPosition = start + formattedText.length;
            textInput.setSelectionRange(newPosition, newPosition);
            
            updateTextCount();
            
            console.log('已应用文本格式，Web Speech API可能会忽略HTML标签');
        }
        
        // 插入停顿
        function insertPause() {
            const start = textInput.selectionStart;
            const end = textInput.selectionEnd;
            
            // 插入停顿标记
            const pauseMark = ' <break time="500ms"/> ';
            const newText = textInput.value.substring(0, start) + pauseMark + textInput.value.substring(end);
            textInput.value = newText;
            
            // 重新设置光标位置
            const newPosition = start + pauseMark.length;
            textInput.setSelectionRange(newPosition, newPosition);
            
            updateTextCount();
            
            // 显示提示
            console.log('已插入停顿标记，播放时会在此处暂停');
            console.log('插入停顿标记:', pauseMark);
        }
    </script>
</body>
</html>